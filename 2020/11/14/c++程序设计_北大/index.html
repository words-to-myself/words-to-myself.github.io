<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="c从C走进C++函数指针 定义：可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以调用这个函数。这种指向函数的指针变量称为“函数指针”。  定义形式：类型名（*指针变量名）（参数类型1，参数类型2，…..）;  eg：int（*pf）（int，char）;   –含义：pf为函数指针，指向某个函数，该函数返回值类型为int，函数参数为（int，char）  使用方">
<meta property="og:type" content="article">
<meta property="og:title" content="flyinghippo">
<meta property="og:url" content="http://example.com/2020/11/14/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_%E5%8C%97%E5%A4%A7/index.html">
<meta property="og:site_name" content="flyinghippo">
<meta property="og:description" content="c从C走进C++函数指针 定义：可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以调用这个函数。这种指向函数的指针变量称为“函数指针”。  定义形式：类型名（*指针变量名）（参数类型1，参数类型2，…..）;  eg：int（*pf）（int，char）;   –含义：pf为函数指针，指向某个函数，该函数返回值类型为int，函数参数为（int，char）  使用方">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-14T12:13:54.075Z">
<meta property="article:modified_time" content="2020-10-31T02:53:31.470Z">
<meta property="article:author" content="hippo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/11/14/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_%E5%8C%97%E5%A4%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | flyinghippo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">flyinghippo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/14/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_%E5%8C%97%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hippo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyinghippo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-14 20:13:54" itemprop="dateCreated datePublished" datetime="2020-11-14T20:13:54+08:00">2020-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-31 10:53:31" itemprop="dateModified" datetime="2020-10-31T10:53:31+08:00">2020-10-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="c从C走进C"><a href="#c从C走进C" class="headerlink" title="c从C走进C++"></a>c从C走进C++</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li><p>定义：可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以调用这个函数。这种指向函数的指针变量称为“函数指针”。</p>
</li>
<li><p>定义形式：类型名（*指针变量名）（参数类型1，参数类型2，…..）;</p>
</li>
<li><p>eg：int（*pf）（int，char）;   –含义：pf为函数指针，指向某个函数，该函数返回值类型为int，函数参数为（int，char）</p>
</li>
<li><p>使用方法：可以用一个原型匹配的函数的名字给一个函数指针赋值。</p>
</li>
<li><p>要通过函数指针调用其指向的函数，写法为：函数指针名（实参表）；</p>
</li>
<li><p>函数指针和qsort库函数：</p>
<ul>
<li><p>qsort可以对任意类型的数组进行排序，形式如下：</p>
<p>void qsort（void <em>base, int nelem, unsigned int width, int(\</em>pfCompare)(const void *,const void *)）;</p>
</li>
<li><p>base：待排序数组的起始地址</p>
</li>
<li><p>nelem：待排序数组的元素个数</p>
</li>
<li><p>width：待排序数组的每个元素的大小（以字节为单位）</p>
</li>
<li><p>pfCompare：比较函数的地址</p>
</li>
<li><p>pfCompare：函数指针，指向一个比较函数，形式如下：</p>
<p>int 函数名（const void * elem1，const void * elem2）；</p>
</li>
<li><p>比较函数规则：</p>
<ul>
<li>如果* elem1在* elem2前面，则函数返回值是负整数</li>
<li>如果* elem1在* elem2哪个在前边均可，则函数返回值是0</li>
<li>如果* elem1在* elem2后面，则函数返回值是正整数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><ul>
<li>在CMD窗口，跟在可执行文件名后边的那些字符串，称为“命令行参数”。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>argc：代表启动程序时，命令行参数的个数。C/C++规定，可执行程序程序本身的文件名，也算一个命令行参数，因此，argc的值至少是1.</li>
<li>argv：指针数组，其中的每个元素都是一个char*类型的指针，该指针指向一个字符串，这个字符串里就存放着命令行参数。</li>
<li>命令行参数本身就是用空格来分隔的，但是如果本身命令行参数就带空格，可以用双引号引起来</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>C/C++六种位运算符：</p>
<ol>
<li><p>&amp;–按位与</p>
<ul>
<li><p>可用来：某些位清0且同时保证其他位不变</p>
</li>
<li><p>也可用来：获取某变量中的某一位</p>
</li>
</ul>
</li>
<li><p>|–按位或</p>
<p>将变量中的某些位置1且保留其他位不变</p>
</li>
<li><p>^–按位异或</p>
<ul>
<li><p>将某变量中的某些位取反，且保留其他位不变</p>
</li>
<li><p>如果a^b=c，那么c^b=a 以及c^a=b</p>
</li>
<li><p>不通过临时变量，交换两个变量的值：a = a ^ b; b = b ^ a; a = a ^ b; </p>
</li>
</ul>
</li>
<li><p>~–按位非</p>
</li>
<li><p>&lt;&lt;–左移</p>
<ul>
<li>a&lt;&lt;b：将a各二进制位全部左移b位，不会修改a的值</li>
<li>左移n位，相当于乘2^n^，而且左移比乘法操作快的多</li>
</ul>
</li>
<li><p>&gt; &gt;–右移</p>
<p>右移n位，相当于把左操作数除以2^n^，并且结果往小里取整</p>
</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><p>定义：类型名 &amp; 引用名 = 某变量名；</p>
</li>
<li><p>某个变量的引用，等价于这个变量，相当于该变量的一个别名</p>
</li>
<li><p>注意的点：</p>
<ul>
<li>定义引用时一定要将其初始化成引用某个变量</li>
<li>初始化后，它就一直引用该变量，不会再引用别的变量了</li>
<li>引用只能引用变量，不能引用常量和表达式</li>
</ul>
</li>
<li><p>引用可以作为函数的返回值</p>
</li>
<li><p>常引用，定义引用时，前边加const关键字，即为“常引用”。</p>
<ul>
<li>不能通过常引用去修改其引用的内容，但是不代表其内容不能被修改</li>
<li>const T &amp; 和 T &amp; 是不同的类型。</li>
<li>T &amp; 类型的引用或T类型的变量可以用来初始化const T &amp;类型的引用</li>
<li>const T 类型的常变量和const T &amp;类型的引用不能用来初始化T &amp;类型的引用，除非进行强制类型转换。</li>
</ul>
</li>
<li><p>指针和引用的区别：</p>
<ul>
<li><p>本质上：引用是别名，指针是地址</p>
</li>
<li><p>现象上：指针在运行时可以改变所指向的值，而引用一旦与某个对象绑定后就不再改变。</p>
</li>
<li><p>内存分配：程序为指针变量分配区域，而不为引用分配内存区域。因为引用生命时必须初始化，从而指向一个已经存在的对象，<strong>引用不能为空值</strong>。</p>
</li>
<li><p>编译：程序在编译时分别将指针和引用添加到<strong>符号表</strong>上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为<strong>指针变量的地址值</strong>，而引用在符号表上对应的地址值为<strong>引用对象的地址值</strong>。从某种意义上来说<strong>引用可以被认为是不能改变的指针</strong>。</p>
</li>
<li><p>级数：从理论上来说，对于指针没有级数限制，但是引用只有一级。指向引用的引用是非法的</p>
</li>
</ul>
</li>
</ul>
<h2 id="CONST"><a href="#CONST" class="headerlink" title="CONST"></a>CONST</h2><ul>
<li><p>定义常量</p>
</li>
<li><p>定义常量指针</p>
<ul>
<li>const int * p = &amp; n；</li>
<li>不可通过常量指针修改其指向的内容（其内容可被修改），</li>
<li>且常量指针的指向可以变化</li>
<li>不能把常量指针赋值给非常量指针，反过来可以</li>
<li>函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容。</li>
</ul>
</li>
<li><p>定义常引用</p>
<p>不能通过常引用修改其引用的变量</p>
</li>
</ul>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><ul>
<li>用new运算符实现动态内存分配</li>
</ul>
<ol>
<li><p>分配一个变量  P = new T；T是任意类型名，P是类型为T * 的指针。</p>
<p>​    动态分配一片大小为sizeof（T）字节的内存空间，并且将该内存空间起始地址赋给P</p>
</li>
<li><p>分配一个数组 P = new T[N]；T是任意类型名，P是类型为T * 的指针，N是要分配的数组元素的个数，可以是整型表达式</p>
<p>​    动态分配一片大小为N*sizeof（T）字节的内存空间，并且将该内存空间起始地址赋给P</p>
</li>
</ol>
<ul>
<li><p>new运算符的返回值的类型：是new出来的数据类型的指针</p>
</li>
<li><p>用new动态分配的内存空间，一定要用delete运算符进行释放。</p>
<p>delete 指针； 该指针必须指向new出来的空间，别的变量指针等会出错</p>
</li>
<li><p>用delete释放动态分配的数组，要加[]</p>
<p>delete [] 指针；</p>
</li>
</ul>
<h2 id="内联函数和重载函数"><a href="#内联函数和重载函数" class="headerlink" title="内联函数和重载函数"></a>内联函数和重载函数</h2><p>内联函数：</p>
<ul>
<li>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。</li>
<li>为了减少函数调用的开销，引入内联函数机制。编译器对内联函数调用时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</li>
<li>在函数定义前面加“inline”关键字，即可定义内联函数。</li>
</ul>
<p>函数重载：</p>
<ul>
<li><p>一个或多个函数，名字相同，然而<strong>参数个数</strong>和<strong>参数类型</strong>不相同，这叫做函数的重载。</p>
</li>
<li><p>函数重载使得函数命名变得简单</p>
</li>
<li><p>编译器根据调用语句中的实参的个数和类型判断应该调用哪个函数。</p>
</li>
<li><p>eg：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> f1, <span class="keyword">double</span> f2)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n1,<span class="keyword">int</span> n1)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2,<span class="keyword">int</span> n3)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="函数缺省参数"><a href="#函数缺省参数" class="headerlink" title="函数缺省参数"></a>函数缺省参数</h2><ul>
<li>定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。</li>
<li>函数参数可缺省的目的在于提高程序的可扩充性。</li>
<li>如果某个写好的函数要添加新的参数，而原先哪些调用该函数的语句，未必需要使用新增的参数，那么为了避免对这些函数进行修改，就可以使用缺省参数。</li>
</ul>
<h2 id="面向对象程序设计方法"><a href="#面向对象程序设计方法" class="headerlink" title="面向对象程序设计方法"></a>面向对象程序设计方法</h2><p>类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    访问范围说明符：</span><br><span class="line">        成员变量<span class="number">1</span></span><br><span class="line">        成员变量<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">        成员函数声明<span class="number">1</span></span><br><span class="line">        成员函数声明<span class="number">2</span></span><br><span class="line">    访问范围说明符：</span><br><span class="line">        更多成员变量</span><br><span class="line">        更多成员函数声明</span><br><span class="line">        ...  </span><br><span class="line">&#125;; <span class="comment">//必须有分号</span></span><br></pre></td></tr></table></figure>

<h2 id="面向对象语言的发展历程"><a href="#面向对象语言的发展历程" class="headerlink" title="面向对象语言的发展历程"></a>面向对象语言的发展历程</h2><p>发展历程</p>
<h2 id="从客观事物抽象出类的例子"><a href="#从客观事物抽象出类的例子" class="headerlink" title="从客观事物抽象出类的例子"></a>从客观事物抽象出类的例子</h2><p>类定义例子;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> w,h;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span></span>&#123;</span><br><span class="line">    	w = w_; h = h_;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> w*h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Perimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">2</span>*(w+h);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类调用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w&gt;&gt;h;</span><br><span class="line">    r.Init(w,h);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;r.Area()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;r.Perimeter();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象的内存分配：</p>
<ul>
<li>对象的大小等于所有成员变量的大小之和</li>
<li>每个对象各有自己的存储空间，一个对象的某个成员变量被改变，不会影响到其他的对象</li>
</ul>
<p>对象间的运算：</p>
<ul>
<li>对象之间可以用‘=’进行赋值</li>
<li>不能用‘==’，‘！=’，‘&gt;’,’&lt;’,’&lt;=’,’&gt;=’进行比较，除非这些运算符经过了重载</li>
</ul>
<p>访问类的成员变量和成员函数：</p>
<ul>
<li>用法1：对象名.成员名</li>
<li>用法2：指针-&gt;成员名</li>
<li>用法3：引用名.成员名</li>
</ul>
<p>类的成员函数的另一种写法（成员函数体和类的定义分开写）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> w,h;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Perimeter</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRectangle::Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRectangle::Perimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(w+h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::Init</span><span class="params">(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span></span>&#123;</span><br><span class="line">    w = w_; h = h_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类成员的可访问范围"><a href="#类成员的可访问范围" class="headerlink" title="类成员的可访问范围"></a>类成员的可访问范围</h2><p>通过关键字确定类成员可被访问的范围：</p>
<ul>
<li>private：指定私有成员，只能在成员函数内被访问</li>
<li>public：指定共有成员，可以在任何地方被访问</li>
<li>protected：指定保护成员</li>
<li>三种关键字出现的次数和先后次序都没有限制</li>
<li>缺省为私有成员</li>
</ul>
<p>对象成员的访问权限：</p>
<ul>
<li>类的成员函数内部，可以访问：<ul>
<li>当前对象的全部属性，函数</li>
<li>同类其他对象的全部属性，函数</li>
</ul>
</li>
<li>类的成员函数以外的地方：<ul>
<li>只能够访问该类对象的公有成员（public）</li>
</ul>
</li>
</ul>
<p>设置私有成员的目的：</p>
<ul>
<li>强制对成员变量的访问一定要通过成员函数进行</li>
</ul>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="内联成员函数和重载成员函数"><a href="#内联成员函数和重载成员函数" class="headerlink" title="内联成员函数和重载成员函数"></a>内联成员函数和重载成员函数</h2><p> 内联成员函数定义方式：</p>
<ol>
<li>inline + 成员函数</li>
<li>整个函数体出现在类定义内部</li>
</ol>
<ul>
<li>成员函数也可以有重载的操作，同时也可以带缺省参数。</li>
<li>使用缺省参数要注意避免有函数重载时的二义性</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>成员函数的一种</li>
<li>名字与类名相同，可以有参数，不能有返回值（void也不行）</li>
<li>作用是对对象进行初始化，如给成员变量赋初值</li>
<li>如果定义类时，没写构造函数，则编译器生成一个默认的无参数的构造函数，默认构造函数无参数，不做任何操作</li>
<li>对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数</li>
<li>一个类可以有多个构造函数，参数个数或类型不同，构成重载的关系</li>
</ul>
<p>eg：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;</span><br><span class="line">    real = r;imag = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数在数组中的使用：</p>
<p>可以构建数组型的对象，每个数组元素里边都有一个对象。</p>
<h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><ul>
<li>只有一个参数，即<strong>对同类对象的引用</strong></li>
<li>形如X::X(X&amp;) 或 X::X(const X&amp;)，二者选一，后者能以常量的对象作为参数</li>
<li>如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。</li>
<li>如果定义自己的复制构造函数，则默认的复制构造函数不存在。</li>
<li>不允许有形如X::X(X) 的构造函数</li>
</ul>
<p>复制构造函数起作用的三种情况：</p>
<ul>
<li>当用一个对象去初始化同类的另一个对象时。</li>
<li>如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。</li>
<li>如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。</li>
</ul>
<h2 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h2><ul>
<li>目的：实现类型的自动转换</li>
<li>特点：1. 只有一个参数 2. 不是复制构造函数</li>
<li>使赋值语句左右不一致的赋值变得一致化</li>
<li>其会生成一个临时变量</li>
</ul>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul>
<li>成员函数的一种，名字与类名相同</li>
<li>在前边加‘~’</li>
<li>没有参数和返回值</li>
<li>一个类最多只有一个析构函数</li>
<li>在对象消亡时，自动的被调用</li>
<li>定义类时没写析构函数，则编译器生成缺省析构函数，定义了析构函数，则编译器不生成缺省析构函数。</li>
<li>对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。</li>
<li>delete 运算也会导致析构函数的调用</li>
<li>离对象最近的一对‘{}’表征了对象的作用范围，离开了该作用域，对象析构</li>
<li>先被构造的对象会最后被析构掉</li>
</ul>
<h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h2><ul>
<li>静态成员：在说明前面加了static关键字的成员。静态成员变量和静态成员函数。</li>
<li>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享</li>
<li>sizeof 运算符不会计算静态成员变量。</li>
<li>普通成员函数必须作用域某个对象，而静态成员函数并不具体作用于某个对象</li>
<li>因此，静态成员不需要通过对象就可以访问</li>
</ul>
<p>如何访问静态成员：</p>
<ol>
<li>类名::成员名    CRectangle::PrintTotal();</li>
<li>对象名.成员名    CRectangle r; r.PrintTotal();</li>
<li>指针-&gt;成员名   CRectangle *p = &r; p-&gt;PrintTotal();</li>
<li>引用.成员名    CRectangle &amp;ref  = r; int n = ref.TotalNumber;</li>
</ol>
<ul>
<li>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在</li>
<li>静态成员函数本质上是全局函数。</li>
<li>必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。</li>
<li>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<h2 id="成员对象和封闭类的概念"><a href="#成员对象和封闭类的概念" class="headerlink" title="成员对象和封闭类的概念"></a>成员对象和封闭类的概念</h2><ul>
<li><p>成员对象：一个类的成员变量是另一个类的对象</p>
</li>
<li><p>包含成员对象的类叫封闭类</p>
</li>
<li><pre><code class="c++">class CTyre&#123;
    private:
        int radius;
        int width;
    public:
        CTyre(int r,int w):radius(r),width(w)&#123;&#125;; //列表初始化
&#125;;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 封闭类构造函数的初始化列表</span><br><span class="line"></span><br><span class="line">  - 定义封闭类的构造函数时，添加初始化列表：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;c++</span><br><span class="line">  类名::构造函数（参数表）:成员变量1（参数表），成员变量2（参数表），....</span><br><span class="line">  &#123;</span><br><span class="line">      ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

- 成员你对象初始化列表中的参数
  - 任意复杂的表达式
  - 函数/变量/表达式中的函数，变量有定义</code></pre>
</li>
<li><p>调用顺序</p>
<ul>
<li>当封闭类对象生成时，<ul>
<li>先执行所有成员对象的构造函数</li>
<li>再执行封闭类的构造函数</li>
</ul>
</li>
<li>成员对象的构造函数的调用顺序<ul>
<li>和成员对象在类中的说明顺序一致</li>
<li>与在成员初始化列表中出现的顺序无关</li>
</ul>
</li>
<li>在封闭类的对象消亡时，<ul>
<li>先执行封闭类的析构函数</li>
<li>再执行成员对象的析构函数</li>
</ul>
</li>
<li>析构函数顺序和构造函数的调用顺序相反</li>
</ul>
</li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元函数：</p>
<ul>
<li>一个类的私有成员只能是内部的成员函数来进行访问，但是一个类的友元函数可以访问该类的私有成员。利用friend关键字声明友元</li>
<li>可以将一个类的成员函数（包括构造和析构函数）声明成另一个类的友元</li>
</ul>
<p>友元类：</p>
<ul>
<li>A是B的友元类，则A的成员函数可以访问B的私有成员</li>
<li>友元类之间的关系不能传递，不能继承</li>
</ul>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ul>
<li><p>感觉有点类似于python的self</p>
</li>
<li><p>C++到C的翻译示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> price;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CCar::SetPrice</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;price = p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CCar car;</span><br><span class="line">    car.SetPrice(<span class="number">20000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(struct CCar * <span class="keyword">this</span>,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">this</span>-&gt;price = p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CCar</span> <span class="title">car</span>;</span></span><br><span class="line">    SetPrice(&amp;car,<span class="number">20000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>this指针的作用<ul>
<li>就是指向成员函数所作用的对象</li>
<li>非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针</li>
</ul>
</li>
<li>this指针和静态成员函数<ul>
<li>静态成员函数中不能使用this指针</li>
<li>因为静态成员函数并不具体作用于某个对象</li>
<li>因此，静态成员函数的真实的参数个数就是程序中写出的参数个数</li>
</ul>
</li>
</ul>
<h2 id="常量对象、常量成员函数和常引用"><a href="#常量对象、常量成员函数和常引用" class="headerlink" title="常量对象、常量成员函数和常引用"></a>常量对象、常量成员函数和常引用</h2><p>常量对象：</p>
<ul>
<li><p>常量对象不可被修改</p>
</li>
<li><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在<strong>前面</strong>加const关键字</p>
</li>
</ul>
<p>常量成员函数：</p>
<ul>
<li>在类的成员函数<strong>后面</strong>可以加const关键字，则该成员函数成为常量成员函数。</li>
<li>常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。</li>
</ul>
<p>注意：</p>
<ul>
<li>常量对象上面不能执行非常量成员函数。</li>
<li>常量对象上可以执行常量成员函数。</li>
</ul>
<p>常量成员函数的重载：</p>
<ul>
<li>两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载</li>
</ul>
<p>常引用：</p>
<ul>
<li>引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量。</li>
</ul>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="运算符重载的基本概念"><a href="#运算符重载的基本概念" class="headerlink" title="运算符重载的基本概念"></a>运算符重载的基本概念</h2><ul>
<li><p>C++提供了数据抽象的手段，用户可以自己定义自己的数据类型–类，调用类的成员函数可以操作对象。</p>
</li>
<li><p>但是操作通过操作类的成员函数来操作对象很不方便，所有采用运算符重载</p>
</li>
<li><p>其目的是想对抽象的数据类型也能直接使用c++提供的运算符</p>
</li>
<li><p>运算符重载：</p>
<ul>
<li>对已有的运算符赋予多重的含义</li>
<li>使同一运算符作用于不同类型的数据时，产生不同类型的行为</li>
</ul>
</li>
<li><p>运算符重载的实质是函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span> 运算符 (形参表)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符可以被重载成普通函数，其参数个数为运算符目数</p>
</li>
<li><p>也可以被重载成类的成员函数，参数个数为运算符目数减一</p>
</li>
</ul>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><ul>
<li>对象可以用赋值运算符进行赋值</li>
<li>赋值运算符两边的类型可以不匹配，但是需要重新赋值运算符‘=’</li>
<li>赋值运算符‘=’只能重载为成员函数，不能重载为普通函数</li>
</ul>
<h2 id="运算符重载为友元函数"><a href="#运算符重载为友元函数" class="headerlink" title="运算符重载为友元函数"></a>运算符重载为友元函数</h2><p>重载为友元函数的情况：</p>
<ol>
<li>成员函数不能满足使用要求</li>
<li>普通函数又不能访问类的私有成员</li>
</ol>
<h2 id="实例-–-长度可变的整型数组类"><a href="#实例-–-长度可变的整型数组类" class="headerlink" title="实例 – 长度可变的整型数组类"></a>实例 – 长度可变的整型数组类</h2><h2 id="流插入运算符和流提取运算符的重载"><a href="#流插入运算符和流提取运算符的重载" class="headerlink" title="流插入运算符和流提取运算符的重载"></a>流插入运算符和流提取运算符的重载</h2><ul>
<li>cout是在iostream中定义得，ostream类的对象</li>
<li>‘&lt;&lt;’能用在cout上是因为，在iostream里对“&lt;&lt;”进行了重载</li>
</ul>
<h2 id="自增-自减运算符的重载"><a href="#自增-自减运算符的重载" class="headerlink" title="自增/自减运算符的重载"></a>自增/自减运算符的重载</h2><ul>
<li><p>自加、自减运算符有前置/后置之分</p>
</li>
<li><p>前置运算符作为一元运算符重载</p>
<ul>
<li><p>重载为成员函数</p>
<p>T operator++();</p>
<p>T operator–();</p>
</li>
<li><p>重载为全局函数：</p>
<p>T operator++(T);</p>
<p>T operator–(T);</p>
</li>
</ul>
</li>
<li><p>后置运算符作为二元运算符重载</p>
<ul>
<li><p>多写一个参数，具体无意义</p>
</li>
<li><p>重载为成员函数</p>
<p>T operator++(int);</p>
<p>T operator–(int);</p>
</li>
<li><p>重载为全局函数：</p>
<p>T operator++(T,int);</p>
<p>T operator–(T,int);</p>
</li>
</ul>
</li>
<li><p>类型强制转换运算符重载时，</p>
<ul>
<li>不能写返回值类型</li>
<li>实际上其返回值类型 就是 类型强制转换运算符代表的类型</li>
</ul>
</li>
<li><p>运算符重载注意事项</p>
<ul>
<li>c++不允许定义新的运算符</li>
<li>重载后的运算符的含义应该符合日常习惯</li>
<li>运算符重载不改变运算符的优先级</li>
<li>以下运算符不能被重载：‘’.“，”.*“，”::“，”?:“，sizeof</li>
<li>重载运算符(),[],-&gt;,=时，重载函数必须声明为类的成员函数</li>
</ul>
</li>
</ul>
<h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><h2 id="继承与派生-1"><a href="#继承与派生-1" class="headerlink" title="继承与派生"></a>继承与派生</h2><ul>
<li><p>继承：在定义一个新的类B时，如果该类与某个已有的类A相似（B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类（子类）</p>
</li>
<li><p>派生类可以通过对基类进行修改和扩充得到。在派生类中，可以扩充新的成员函数和成员变量。</p>
</li>
<li><p>派生类一经定义，可以独立使用，不依赖与基类</p>
</li>
<li><p>派生类拥有基类的全部成员函数和成员变量，无论是private，protected，public</p>
</li>
<li><p>在派生类的各个成员函数中，不能访问基类中的private成员</p>
</li>
<li><p>派生类的写法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名:<span class="keyword">public</span> 基类名</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。</p>
</li>
<li><p>在派生类对象中，包含着基类的对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。</p>
</li>
</ul>
<h2 id="复合关系和继承关系"><a href="#复合关系和继承关系" class="headerlink" title="复合关系和继承关系"></a>复合关系和继承关系</h2><h2 id="基类-派生类同名成员和protected访问范围说明符"><a href="#基类-派生类同名成员和protected访问范围说明符" class="headerlink" title="基类/派生类同名成员和protected访问范围说明符"></a>基类/派生类同名成员和protected访问范围说明符</h2><p>访问范围说明符：</p>
<ul>
<li><p>基类的private成员：可以被下列函数访问：</p>
<ol>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
</ol>
</li>
<li><p>基类的public成员：可以被下列函数访问：</p>
<ol>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数</li>
<li>派生类的友元函数</li>
<li>其他的函数</li>
</ol>
</li>
<li><p>基类的protected成员：可以被下列函数访问：</p>
<ol>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数可以访问当前对象的基类的保护成员</li>
</ol>
</li>
</ul>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><ul>
<li><p>派生类对象包含基类对象</p>
</li>
<li><p>执行派生类构造函数之前， 先执行基类的构造函数</p>
</li>
<li><p>派生类交代基类初始化，具体形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数名(形参表):基类名(基类构造函数实参表)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在创建派生类的对象时：</p>
<ul>
<li>需要调用基类的构造函数：初始化派生类对象中从基类继承的成员</li>
<li>在执行一个派生类的构造函数之前，总是先执行基类的构造函数</li>
</ul>
</li>
<li><p>调用基类构造函数的两种方式</p>
<ol>
<li><p>显式方式：</p>
<p>派生类的构造函数中，基类构造函数提供参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T:T(arg_T-<span class="built_in">list</span>):base(arg_base-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式方式：</p>
<p>派生类的构造函数中，省略基类构造函数时，派生类的构造函数，自动调用基类的默认构造函数。</p>
</li>
</ol>
</li>
<li><p>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。</p>
</li>
<li><p>创建派生类的对象时，执行派生类的构造函数之前：</p>
<ol>
<li>调用基类的构造函数，来初始化派生类对象中从基类继承的成员</li>
<li>调用成员对象类的构造函数，来初始化派生类对象中的成员函数</li>
</ol>
</li>
<li><p>执行完派生类的析构函数后：</p>
<ol>
<li>调用成员对象类的析构函数</li>
<li>调用基类的析构函数</li>
</ol>
</li>
<li><p>析构函数的调用顺序和构造函数的调用顺序相反</p>
</li>
</ul>
<h2 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h2><ol>
<li>派生类的对象可以赋值给基类对象</li>
<li>派生类对象可以初始化基类引用</li>
<li>派生类对象的地址可以赋值给基类指针</li>
<li>如果派生方式是private或protected，则上述三条不可用</li>
</ol>
<ul>
<li>直接基类和间接基类 <ul>
<li>声明派生类时，只需列出它的直接基类，派生类会沿着类的层次自动向上继承他的间接基类</li>
<li>派生类的成员包括：<ol>
<li>派生类自己定义的成员</li>
<li>直接基类中的所有成员</li>
<li>所有间接基类的全部成员</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="多态与虚函数"><a href="#多态与虚函数" class="headerlink" title="多态与虚函数"></a>多态与虚函数</h1><h2 id="多态与虚函数的基本概念"><a href="#多态与虚函数的基本概念" class="headerlink" title="多态与虚函数的基本概念"></a>多态与虚函数的基本概念</h2><ul>
<li><p>有类和继承等概念，但是没有多态的程序语言成为基于对象的程序语言，不能叫做面向对象的程序语言</p>
</li>
<li><p>在类的定义中，前面有virtual关键字的成员函数就是虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base::get</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>virtual关键字只能用在类定义里的函数声明中，写函数体时不用</p>
</li>
<li><p>构造函数和静态成员函数不能是虚函数</p>
</li>
<li><p>虚函数可以参与多态，普通的成员函数不可以</p>
</li>
</ul>
<p>多态：</p>
<ul>
<li><p>多态的表现形式一：</p>
<ul>
<li>派生类的指针可以赋给基类指针</li>
<li>通过基类指针调用基类和派生类中的同名虚函数时：<ul>
<li>若该指针指向一个基类的对象，那么被调用是基类的虚函数</li>
<li>若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数</li>
</ul>
</li>
</ul>
</li>
<li><p>多态的表现形式二：</p>
<ul>
<li>派生类的指针可以赋给基类引用</li>
<li>通过基类引用调用基类和派生类中的同名虚函数时：<ul>
<li>若该引用引用的是一个基类的对象，那么被调用是基类的虚函数</li>
<li>若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数</li>
</ul>
</li>
</ul>
</li>
<li><p>多态的作用：</p>
<p>能够增强程序的可扩充性</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6/" rel="prev" title="概率论与数理统计_浙江大学">
      <i class="fa fa-chevron-left"></i> 概率论与数理统计_浙江大学
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E4%BB%8EC%E8%B5%B0%E8%BF%9BC"><span class="nav-number">1.</span> <span class="nav-text">c从C走进C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.</span> <span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.3.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CONST"><span class="nav-number">1.5.</span> <span class="nav-text">CONST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.6.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.</span> <span class="nav-text">内联函数和重载函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">函数缺省参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.</span> <span class="nav-text">面向对象程序设计方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">1.10.</span> <span class="nav-text">面向对象语言的发展历程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%AE%A2%E8%A7%82%E4%BA%8B%E7%89%A9%E6%8A%BD%E8%B1%A1%E5%87%BA%E7%B1%BB%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.11.</span> <span class="nav-text">从客观事物抽象出类的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4"><span class="nav-number">1.12.</span> <span class="nav-text">类成员的可访问范围</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">内联成员函数和重载成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">复制构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text">类型转换构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.</span> <span class="nav-text">静态成员变量和静态成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E9%97%AD%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.</span> <span class="nav-text">成员对象和封闭类的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">2.8.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">2.9.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="nav-number">2.10.</span> <span class="nav-text">常量对象、常量成员函数和常引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">运算符重载的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">3.2.</span> <span class="nav-text">赋值运算符的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">运算符重载为友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-%E2%80%93-%E9%95%BF%E5%BA%A6%E5%8F%AF%E5%8F%98%E7%9A%84%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84%E7%B1%BB"><span class="nav-number">3.4.</span> <span class="nav-text">实例 – 长度可变的整型数组类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E6%8F%92%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">3.5.</span> <span class="nav-text">流插入运算符和流提取运算符的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">3.6.</span> <span class="nav-text">自增&#x2F;自减运算符的重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F"><span class="nav-number">4.</span> <span class="nav-text">继承与派生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F-1"><span class="nav-number">4.1.</span> <span class="nav-text">继承与派生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%92%8C%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">4.2.</span> <span class="nav-text">复合关系和继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%92%8Cprotected%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-number">4.3.</span> <span class="nav-text">基类&#x2F;派生类同名成员和protected访问范围说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">派生类的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#public%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99"><span class="nav-number">4.5.</span> <span class="nav-text">public继承的赋值兼容规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">多态与虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">多态与虚函数的基本概念</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hippo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hippo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
